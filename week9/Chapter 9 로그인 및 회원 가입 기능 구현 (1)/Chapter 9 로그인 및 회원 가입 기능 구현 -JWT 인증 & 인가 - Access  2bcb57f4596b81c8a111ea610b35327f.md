# Chapter 9. 로그인 및 회원 가입 기능 구현 -JWT 인증 & 인가 - Access/Refresh 흐름 제대로 이해하기

### 👉 인증? 인가?

먼저 로그인과 회원가입 기능을 구현하기 전에, 가장 혼동하기 쉬운 두 가지 개념을 바로잡아 보겠습니다.

먼저 인증부터 알아보도록 하겠습니다. 

**인증 (Authentication) - 당신은 누구십니까?**

**인증**은, 사용자가 누구인지 확인하는 과정입니다. 예시로는 웹사이트에 아이디와 비밀번호를 입력해 로그인하는 행위가 있습니다. 

**인가(Authorization) - 이걸 할 권한이 있나요?**

**인가**는 “인증된” 사용자가 특정 리소스에 접근하거나 특정 동작을 수행할 수 있도록 허가하는 과정입니다.

로그인 한 사용자가 ‘일반 사용자’인지 ‘관리자(Admin)’인지 확인하고, ‘관리자’에게만 ‘유저 삭제’ 등의 기능을 보여주는 것입니다. 

![image.png](Chapter%209%20%EB%A1%9C%EA%B7%B8%EC%9D%B8%20%EB%B0%8F%20%ED%9A%8C%EC%9B%90%20%EA%B0%80%EC%9E%85%20%EA%B8%B0%EB%8A%A5%20%EA%B5%AC%ED%98%84%20-JWT%20%EC%9D%B8%EC%A6%9D%20&%20%EC%9D%B8%EA%B0%80%20-%20Access%20/image.png)

### 👉 핵심 관계: 인증이 먼저, 인가는 다음!

인증과 인가의 차이를 보니 감이 오시나요? 

‘인가’는 ‘인증’을 통과한 사용자에게만 의미가 있습니다. 

JWT 같은 토큰으로 “이 사용자가 `userId: 1` 번 유저가 맞는지” **인증**합니다. 그 다음 “1번 유저가 ‘관리자’ 권한을 가졌는지 **인가** 절차를 거치는 것입니다.  

### 👉 인증을 구현하는 2가지 방법: 세션 vs 토큰

그렇다면 “인증(Authentication)”을 신분증 검사에 비유할 수 있겠네요? 맞습니다.

그러면 서버는 이 ‘신분증’ 을 어떻게 확인하고 ‘로그인 상태’를 어떻게 유지할까요? 여기에는 크게 2가지 방식이 있습니다. JWT를 이해하기 위해서는 **‘세션’** 방식을 알아두는 것이 좋은데요.

**세션 (Session) 방식**

- 서버가 사용자의 로그인 상태를 **기억**하고 직접 관리합니다. (**Stateful:** 서버가 상태를 유지)
- 사용자가 로그인을 하면, 서버는 “이 사람은 로그인되었습니다” 라는 정보를 서버의 DB/메모리에 저장합니다. 그리고 사용자에게는 쿠키를 주죠. API 요청 시 서버는 이 쿠키를 보고 사용자를 확인합니다.

그리고 세션 방식에 대한 이정도 이해를 가지고 JWT 방식에 대해 알아보겠습니다. 

### 👉 JWT 인증과 Access / Refresh 흐름

7주차의 `isLogin` 예제가 혹시 생각나시나요?

그 예제에서는 `username` 쿠키 하나만 사용했습니다. 그런데 만약 이 쿠키가 탈취당한다면, 해커가 여러분의 계정을 영원히 사용할 수 있는 불미스러운 일이 생길 것입니다..

이런 보안 문제를 해결하고, 더 안전하게 사용자를 인증하기 위해 **JWT(JSON Web Token)**와 **토큰 2개(Access/Refresh)**를 사용합니다. 

### 👉 JWT: 위조 불가능한 신분증

JWT(JSON Web Token)는 사용자의 정보를 담은 JSON 객체를 ‘암호화 서명’한 특별한 토큰입니다. 이름 그대로 ‘JSON 기반의 웹 토큰’ 이죠.

공식적으로 **인증(Authentication)& 인가(Authorization) 방식**으로 사용됩니다. 

JWT는 `.` 으로 구분된 세 부분으로 이루어져 있습니다. 

![image.png](Chapter%209%20%EB%A1%9C%EA%B7%B8%EC%9D%B8%20%EB%B0%8F%20%ED%9A%8C%EC%9B%90%20%EA%B0%80%EC%9E%85%20%EA%B8%B0%EB%8A%A5%20%EA%B5%AC%ED%98%84%20-JWT%20%EC%9D%B8%EC%A6%9D%20&%20%EC%9D%B8%EA%B0%80%20-%20Access%20/image%201.png)

1. Header(헤더) : 토큰의 타입, 서명 알고리즘(예: HS256) 정보를 담습니다. 
2. Payload(페이로드) : `userId: 1` , `email: "jeaseo@...com"` 처럼 우리가 사용자를 식별할 수 있는 **실제 정보**가 담깁니다. (민감한 정보, 예를 들어 비밀번호는 절대 넣으면 안 됩니다)
3. Signature(서명) : 이 토큰이 ‘위조’되지 않았음을 증명하는 ‘비밀 키’ 기반의 서명입니다. 서버는 오직 이 서명만 확인하면 토큰이 진짜임을 100% 믿을 수 있습니다.

서버는 클라이언트가 이 JWT를 요청 헤더에 담아 보내면, ‘비밀 키’로 서명(Signature)을 검증해서 “아, `userId: 1` 번  유저가 맞구나!” 하고 인증합니다. 

Header와 Payload는 단순히 Base64Url로 인코딩되어 있어 누구나 쉽게 인코딩/디코딩할 수 있지만, Signature은 비밀 키가 없으면 원래대로 검증할 수 없습니다. 이를 통해 **보안상 안전하다**는 특성을 가질 수 있게 되었죠. 

### 👉 직접 확인해 보기

[https//jwt.io/](https://www.jwt.io/) 에 들어가 token 값을 입력하면 현재 자신이 사용 중인 jwt 토큰이 어떤 구조로 되어있는지 눈으로 쉽게 확인할 수 있습니다. 

![image.png](Chapter%209%20%EB%A1%9C%EA%B7%B8%EC%9D%B8%20%EB%B0%8F%20%ED%9A%8C%EC%9B%90%20%EA%B0%80%EC%9E%85%20%EA%B8%B0%EB%8A%A5%20%EA%B5%AC%ED%98%84%20-JWT%20%EC%9D%B8%EC%A6%9D%20&%20%EC%9D%B8%EA%B0%80%20-%20Access%20/image%202.png)

한번 직접 확인해보면 좋은 실습이 될 거에요!

### 👉 왜 토큰을 2개(Access/Refresh)나 사용할까요?

“보안” 과 “편의성” 두 마리의 토끼를 모두 잡기 위해서입니다.

만약 수명이 긴(예: 30일) JWT 토큰 하나만 쓴다면, 7주차의 쿠키처럼 탈취당했을 때 30일 내내 해커에게 계정을 빼앗기게 되겠죠.

그렇다고 수명을 10분으로 줄인다면, 사용자는 10분마다 다시 로그인해야 하니 끔찍하게 불편한 일이 생길 것입니다. 

그래서 “단기 출입증(Access)”과 “출입증 재발급용 카드(Refresh)” 두 가지 토큰을 사용합니다. 

1. **🔑 액세스 토큰 (Access Token) - "단기 출입증”**

액세스 토큰은 수명이 아주 짧습니다. 용도로는 `/mypage` , `write` 등 일반적인 API 요청에 사용됩니다. 탈취당해도 1시간만 유효하므로 피해가 적습니다.

 **2.   🔄 리프레시 토큰 (Refresh Token) - "출입증 재발급용 카드”**

리프레시 토큰은 수명이 긴데요. 용도는 오직 **“새로운 액세스 토큰을 재발급”** 받는 용도로만 사용됩니다. 이 토큰은 DB 등 안전한 곳에 보관합니다. 

### 👉  Access / Refresh 토큰의 실제 흐름

토큰의 흐름을 한번 살펴보겠습니다.

![image.png](Chapter%209%20%EB%A1%9C%EA%B7%B8%EC%9D%B8%20%EB%B0%8F%20%ED%9A%8C%EC%9B%90%20%EA%B0%80%EC%9E%85%20%EA%B8%B0%EB%8A%A5%20%EA%B5%AC%ED%98%84%20-JWT%20%EC%9D%B8%EC%A6%9D%20&%20%EC%9D%B8%EA%B0%80%20-%20Access%20/image%203.png)

**1단계: 최초 로그인 및 토큰 발급 (1~4번)**

1. **사용자 로그인**: 사용자가 ID/PW (또는 뒤에서 할 9주차 실습 소셜 로그인)로 서버에 로그인을 요청합니다.
2. **사용자 확인**: 서버는 회원 DB 사용자가 유효한지 확인합니다.
3. **토큰 발급**: 인증에 성공하면, 사용자는 이 사용자를 위한 **Access Token(단기) 과 Refresh Token(장기) 을 둘 다 생성합니다.** 
4. **응답**: 서버가 두 개의 토큰을 모두 사용자(클라이언트) 에게 전달합니다.

**2단계: 정상적인 API 요청 (5~7번)**

1. **데이터 요청**: 사용자가 `mypage` 같은 API를 호출할 때, Access Token을 헤더에 실어 보냅니다. (아무것도 안해도 그냥 보내주지는 않습니다. 직접 구현해야 합니다)
2. **Access Token 검증**: 서버는 이 토큰의 서명과 유효 기간을 ‘검증’합니다. (이때는 아직 유효한 상태입니다)
3. **응답**: 토큰이 유효하므로, 서버는 요청한 데이터를 사용자에게 응답합니다.

**3단계: Access Token 만료 및 재발급 (8~13번)**

1. **Access Token 만료**: 시간이 흘러 Access Token의 수명 시간이 지났다고 가정해 봅시다. 그렇다면 사용자가 갖고 있던 Access Token이 만료됩니다. 
2. **데이터 요청**: 사용자는 만료된 사실을 모르고, **만료된 Access Token**으로 다시 API를 요청합니다.
3. **만료 확인**: 서버가 토큰을 검증(6번) 하려다, “토큰이 만료됐다” 는 것을 확인합니다.
4. **응답(만료 신호)**: 서버는 데이터를 주지 않고, “당신의 Access Token은 만료되었습니다” 라는 **에러 신호**(보통 7주차에 배운 표준 에러 형식으로, `401 Unauthorized` 상태 코드와 함께)를 응답합니다.
5. **Access Token 발급 요청**: 이 부분이 중요한데요. 사용자는 11번의 에러를 받고, “아, 만료됐구나. 새 거 주세요!” 라는 의미로 **(만료된) Access Token**과 **(아직 유효한) Refresh Token**을 함께 서버의 ‘토큰 재발급 API’로 보냅니다. 
6. **응답(새 토큰 발급)**: 서버는 Refresh Token이 유효한지 DB에서 확인한 뒤, 유효하다면 새로운 Access Token을 발급하여 사용자에게 응답합니다. 

이후, 사용자는 방금 받은 ‘새 Access Token’으로 9번에서 실패했던 ‘데이터 요청’을 다시 시도합니다. 그러면 다시 5~7번 흐름으로 돌아가겠죠?