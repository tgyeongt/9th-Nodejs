# [week09] 박태경 미션기록

- 내 정보 수정 API 추가
    
    `index.js`
    
    ```sql
    // 내 정보 수정
    app.patch("/api/v1/users/me", isLogin, handleUpdateMyProfile);
    ```
    
    `user.controller.js`
    
    ```sql
    // 내 정보 수정
    export const handleUpdateMyProfile = async (req, res, next) => {
      try {
        const currentUserId = req.user?.id;
        if (!currentUserId) {
          return res
            .status(StatusCodes.UNAUTHORIZED)
            .error({ errorCode: "AUTH001", reason: "Not authenticated" });
        }
    
        const { userData, preferenceIds } = bodyToUser(req.body); // reuse DTO
        const updated = await updateUserById(
          currentUserId,
          userData,
          preferenceIds || []
        );
        return res.status(StatusCodes.OK).success(updated);
      } catch (err) {
        next(err);
      }
    };
    ```
    
- auth.config.js
    
    ```sql
    import dotenv from "dotenv";
    import { Strategy as GoogleStrategy } from "passport-google-oauth20";
    import { Strategy as JwtStrategy, ExtractJwt } from "passport-jwt";
    import { prisma } from "./db.config.js";
    import jwt from "jsonwebtoken";
    
    dotenv.config();
    
    const secret = process.env.JWT_SECRET;
    
    // JWT 발급 함수
    
    // 액세스 토큰 발급 (1시간 유효)
    export const generateAccessToken = (user) => {
      return jwt.sign({ id: user.id }, secret, {
        expiresIn: "1h",
      });
    };
    
    // 리프레시 토큰 발급 (14일 유효)
    export const generateRefreshToken = (user) => {
      return jwt.sign({ id: user.id }, secret, {
        expiresIn: "14d",
      });
    };
    
    // 구글 OAuth 인증 후 유저 처리
    
    const googleVerify = async (profile) => {
      const email = profile.emails?.[0]?.value;
      if (!email) {
        throw new Error("구글 OAuth에서 이메일 정보를 찾을 수 없습니다.");
      }
    
      // DB에서 유저 찾기
      let user = await prisma.user.findUnique({
        where: { email },
      });
    
      // 유저 존재 시 그대로 사용
      if (user) {
        return user;
      }
    
      // 신규 유저 생성
      user = await prisma.user.create({
        data: {
          email,
          name: profile.displayName ?? "이름 없음",
          gender: "추후 수정",
          birth: new Date(2003, 9, 16),
          address: "추후 수정",
          detailAddress: "추후 수정",
          phoneNumber: "추후 수정",
        },
      });
    
      return user;
    };
    
    // Google OAuth
    
    export const googleStrategy = new GoogleStrategy(
      {
        clientID: process.env.PASSPORT_GOOGLE_CLIENT_ID,
        clientSecret: process.env.PASSPORT_GOOGLE_CLIENT_SECRET,
        callbackURL: "/oauth2/callback/google",
    
        scope: ["profile", "email"],
      },
    
      // 구글 인증 완료 후 실행되는 콜백
      async (accessToken, refreshToken, profile, cb) => {
        try {
          const user = await googleVerify(profile);
    
          const jwtAccessToken = generateAccessToken(user);
          const jwtRefreshToken = generateRefreshToken(user);
    
          return cb(null, {
            accessToken: jwtAccessToken,
            refreshToken: jwtRefreshToken,
            user,
          });
        } catch (err) {
          return cb(err);
        }
      }
    );
    
    // JWT Strategy 설정 (Bearer 인증)
    
    const jwtOptions = {
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      secretOrKey: secret,
    };
    
    export const jwtStrategy = new JwtStrategy(
      jwtOptions,
      async (payload, done) => {
        try {
          const user = await prisma.user.findUnique({
            where: { id: payload.id },
          });
    
          if (user) {
            return done(null, user);
          }
    
          // 유저 없을 시 인증 실패
          return done(null, false);
        } catch (err) {
          return done(err, false);
        }
      }
    );
    
    ```
    
- auth.middleware.js
    
    ```sql
    export const ensureSelfOrAdmin = (req, res, next) => {
      const authUser = req.user;
      const paramUserId = req.params.userId ? Number(req.params.userId) : null;
    
      if (!authUser) {
        return res.status(401).json({ message: "인증이 필요합니다." });
      }
    
      // 만약 관리자인 로직이 있으면 authUser.role === 'admin' 추가
      if (paramUserId && Number(authUser.id) !== paramUserId) {
        // 현재는 본인만 허용
        return res.status(403).json({ message: "권한이 없습니다." });
      }
    
      next();
    };
    
    ```
    
- 9주차 워크북에서 만든 **인증 시스템(JWT)** 을 그동안 만들었던 기존 API들에 적용하여 ‘로그인한 사용자만’ 쓸 수 있도록 보호해 주세요.
    
    회원가입, 특정 지역에 가게 추가하기 기능(관리자 전용)은 `isLogin`을 추가하지 않았습니다. 
    
    `index.js`
    
    ```sql
    /* users */
    // 회원가입
    app.post("/api/v1/users/signup", handleUserSignUp);
    
    // 내 정보 수정
    app.patch("/api/v1/users/me", isLogin, handleUpdateMyProfile);
    
    // 내가 작성한 리뷰 목록
    app.get("/api/v1/users/:userId/reviews", isLogin, handleListUserReviews);
    
    // 내가 진행 중인 미션 목록
    app.get("/api/v1/users/:userId/missions", isLogin, handleListUserMissions);
    
    /* stores */
    // 특정 지역에 가게 추가하기
    app.post("/api/v1/stores", handleAddStore);
    
    // 특정 가게에 리뷰 추가하기
    app.post("/api/v1/stores/:storeId/reviews", isLogin, handleAddReview);
    
    // 특정 가게 리뷰 조회하기
    app.get("/api/v1/stores/:storeId/reviews", isLogin, handleListStoreReviews);
    
    // 특정 가게의 미션 목록 조회하기
    app.get("/api/v1/stores/:storeId/missions", isLogin, handleListStoreMissions);
    
    /* missions */
    // 미션 도전하기
    app.post(
      "/api/v1/missions/:missionId/challenge",
      isLogin,
      handleChallengeMission
    );
    
    // 진행 중인 미션 완료 처리
    app.patch(
      "/api/v1/missions/:missionId/complete",
      isLogin,
      handleCompleteMission
    );
    ```