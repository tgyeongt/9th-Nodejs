# Chapter 6. ORM 사용해보기 - ORM 사용해보기

<aside>
<img src="https://www.notion.so/icons/list_gray.svg" alt="https://www.notion.so/icons/list_gray.svg" width="40px" /> **목차**

</aside>

### 👉 ORM이란?

ORM(Object-Relational Mapping)은 SQL을 직접 사용하는 대신, JavaScript/파이썬 등을 통해 쿼리를 만들고 실행하고 객체를 통해 DB에 접근할 수 있도록 도와주는 라이브러리입니다. SQL을 직접 사용할 때와 비교해 유지보수도 쉬워지고, IDE에서 오류를 찾거나 `<TAB>`으로 자동 완성을 하기도 쉬워집니다.

설명으로는 다소 난해한데, 예시를 하나 보고 아래 실습을 통해서 하나씩 더 자세히 알아볼게요.

본문에서 Repository 코드를 보고 와서 아시겠지만, 원래는 이런 코드를 작성해야 했습니다. 

```sql
SELECT * FROM User WHERE id = 1;
```

하지만 ORM을 사용하면 아래 코드만으로 같은 기능을 구현할 수 있습니다.

```sql
const user = await prisma.user.findUnique({
  where: { id: 1 },
});
```

언뜻 보면 코드 길이가 비슷해 보이지만, 본문의 Repository 코드처럼 긴 코드라면?

```jsx
import { prisma } from "../db.config.js";

export const getUserPreferencesByUserId = async (userId) => {

  try {
    const preferences = await prisma.userFavorCategory.findMany({
      where: {
        user_id: userId,
      },
      orderBy: {
        f_category_id: "asc",
      },
      include: {
        foodCategory: {
          select: {
            f_category_name: true,
          },
        },
      },
    });

    return preferences.map((pref) => ({
      uf_category_id: pref.uf_category_id,
      f_category_id: pref.f_category_id,
      user_id: pref.user_id,
      f_category_name: pref.foodCategory.f_category_name,
    }));
  } catch (err) {
    throw new Error(
      `오류가 발생했어요. 요청 파라미터를 확인해주세요. (${err.message})`
    );
  }
};

```

어떤가요? 훨씬 가독성이 좋아지지 않았나요? 코드에 대한 설명은 뒤에서 할 예정이니 지금은 이 정도만으로 넘어가 주셔도 괜찮습니다. 

### 👉 라이브러리 설치하기

UMC Node.js 파트에서 사용할 ORM 라이브러리는 Prisma입니다. Prisma는 직관적으로 다양한 쿼리를 사용할 수 있는 ORM 라이브러리로, 현재 가장 많이 사용되는 ORM 라이브러리 중 하나입니다.

- GitHub: [https://github.com/prisma/prisma](https://github.com/prisma/prisma)
- Docs: [https://www.prisma.io](https://www.prisma.io/)

![[npmtrends](https://npmtrends.com/prisma-vs-sequelize-vs-typeorm)에서도 Prisma가 가장 많이 사용되고 있는 것을 알 수 있습니다.](Chapter%206%20ORM%20%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EA%B8%B0%20-%20ORM%20%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EA%B8%B0/16459.png)

[npmtrends](https://npmtrends.com/prisma-vs-sequelize-vs-typeorm)에서도 Prisma가 가장 많이 사용되고 있는 것을 알 수 있습니다.

이번 주차의 실습에 필요한 라이브러리들은 아래와 같아요. 아래 스크립트를 복사해 실행해주세요!

```bash
npm install \
  @prisma/client \
  prisma
```

### 👉 Prisma 설정 파일 만들기

처음 Prisma 라이브러리를 설치하면, 아래와 같이 명령어를 실행해서 기본 Prisma 설정 파일을 생성해주세요.

```bash
npm exec prisma init
```

![CleanShot 2024-09-15 at 13.40.43@2x.png](Chapter%206%20ORM%20%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EA%B8%B0%20-%20ORM%20%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EA%B8%B0/CleanShot_2024-09-15_at_13.40.432x.png)

그러면 `prisma/schema.prisma` 파일이 생성되고, `.env` 파일에는 `DATABASE_URL` 항목이 추가되었을 거예요. 하나씩 살펴보며 수정해보도록 하겠습니다.

### 👉 schema. prisma 파일 구조 살펴보기

```jsx
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
 // output   = "../src/generated/prisma" <- 이 부분이 생겼다면 지워주세요! 
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

```

생성된 `prisma/schema.prisma` 파일을 한번 봐볼까요?

먼저 주석 부분을 보면 다음과 같습니다. 

`schema.prisma` 는 Prisma의 핵심 설정 파일입니다.

이 안에서 데이터베이스 테이블 구조(=모델)와 데이터 소스(DB연결), 그리고 Prisma 클라이언트 설정을 정의합니다. 안에 있는 링크는 공식 문서와 연결되어 있습니다. Prisma 문법과 설정 방법을 배울 수 있으니 한번 쯤 정독해 보시는 것을 추천! 

- 공식 문서 😀
    
    [Prisma Schema Overview](https://www.prisma.io/docs/orm/prisma-schema/overview)
    

그리고 주석의 두 번째 문단은 Prisma Accelerate라는 부가 기능에 관한 안내입니다.

Accelerate는 대규모 프로젝트 같은 곳에서 쿼리를 더 빠르게 캐싱하거나 서버리스 환경에서 Prisma를 최적화하기 위한 서비스입니다. 

지금은 학습 단계이니 넘어가도 괜찮습니다. 😉

중요한 부분은 이 블록입니다.

```jsx
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}
```

이 블록은 **Prisma Client 생성 설정**입니다.

Prisma는 `schema.prisma` 에 작성된 모델을 바탕으로 데이터베이스를 조작할 수 있는 자동 생성된 **자바스크립트 코드**(클라이언트)를 만들어 줍니다. 

 "prisma-client-js" 부분은 Node.js용 Prisma 클라이언트를 생성하겠다는 뜻입니다. 

처음 `npm exec prisma init`을 통해 Schema 파일을 생성하게 되면 PostgreSQL로 생성되는데 이를 MySQL로 변경해주었습니다.

### 👉 환경 변수 수정하기

`.env` 파일의 `DATABASE_URL`도 수정해야 되겠죠? 아래와 같이 적절히 수정해주시기 바랍니다. 기존에 사용하던 호스트, 포트, 사용자 이름, 패스워드, 스키마 이름 등을 넣어주시면 됩니다.

```bash
DATABASE_URL="mysql://<DB_USER>:<DB_PASSWORD>@<DB_HOST>:<DB_PORT>/<DB_NAME>"
# ex. DATABASE_URL="mysql://root:password@localhost:3306/umc_7th"
```

### 👉 Prisma Schema에 Model 추가하기

Prisma에서는 Model을 통해 테이블을 표현하고, 이 Model을 이용해 DB에 데이터를 조회하고 생성하는 등의 작업을 하게 됩니다.

기존에 저희가 사용하던 테이블 가운데, 먼저 `User` 테이블을 Model로 정의해보도록 하겠습니다. 이 Model은 모두 `prisma/schema.prisma` 파일에 추가해주시면 됩니다.

```jsx
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model User {
  id            Int      @id @default(autoincrement())
  email         String   @unique(map: "email") @db.VarChar(255)
  name          String   @db.VarChar(100)
  gender        String   @db.VarChar(15)
  birth         DateTime @db.Date
  address       String   @db.VarChar(255)
  detailAddress String?  @map("detail_address") @db.VarChar(255)
  phoneNumber   String   @map("phone_number") @db.VarChar(15)

  @@map("user")
}
```

Prisma에서는 테이블 이름과 컬럼 이름이 자동으로 매핑됩니다. 하지만 `detailAddress`와 같은 컬럼도 DB에 그대로 적용되는 문제가 있습니다.

이런 문제를 해결하기 위해 테이블 이름, 컬럼 이름은 JavaScript에서 사용하기 편리한 `camelCase` 방식으로 정의하고, `@@map`과 `@map` 키워드를 이용해서 테이블 이름, 컬럼 이름을 각각 덮어씌울 수 있습니다.

위의 `User` Model은 `user` 테이블의 모든 컬럼에 대한 정보를 표현하고 있는 것으로 봐주시면 됩니다.

### 👉 Client 코드 만들기

Prisma에서는 위와 같이 Schema 파일을 수정하면, 이를 기반으로 JavaScript Client 코드를 생성한 후에 사용할 수 있습니다. 터미널에 아래 명령어를 입력해주세요!

```jsx
npm exec prisma generate
```

![CleanShot 2024-09-15 at 14.00.13@2x.png](Chapter%206%20ORM%20%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EA%B8%B0%20-%20ORM%20%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EA%B8%B0/CleanShot_2024-09-15_at_14.00.132x.png)

앞으로도 Prisma의 Schema 파일을 수정한 후에는 잊지 않고 `npm exec prisma generate`를 한 번씩 돌려주세요. 하지만 매번 돌려주는 것을 까먹을 수도 있을 것 같습니다. 그래서 지난 번에 사용했던 `nodemon`을 조금 수정해서 사용해보도록 하겠습니다!

```json
{
  "name": "playground-umc-7th-nodejs",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "node src/index.js",
    "dev": "nodemon -e js,json,prisma --exec \"prisma generate && node src/index.js\""
  }
}
```

`package.json` 파일의 `dev` 스크립트를 수정해서, 위와 같이 수정해주세요. 이제 Prisma의 Schema 파일 또는 다른 JavaScript 파일을 수정했을 때, 자동으로 Client 코드를 생성하고 서버도 재시작하게 됩니다. (정말 편리하죠?)

![CleanShot 2024-09-15 at 15.08.40@2x.png](Chapter%206%20ORM%20%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EA%B8%B0%20-%20ORM%20%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EA%B8%B0/CleanShot_2024-09-15_at_15.08.402x.png)

Prisma Client를 생성해서 사용하게 되면, IDE에서도 코드를 입력할 때 사진처럼 자동 완성을 보여주게 됩니다!

### 👉 ORM 적용하기

우선 Prisma의 Client 인스턴스는 한 번 생성하여 다른 코드 전체에서 공유해 사용하게 됩니다. 이를 위해 `src/db.config.js`의 상단에 아래와 같이 내용을 추가해주세요.

```jsx
import { PrismaClient } from "@prisma/client";

export const prisma = new PrismaClient();
```

어떤 DB와 어떻게 연결되는지와 같은 정보들은 이미 `prisma/schema.prisma`에 정의되어 있기 때문에, 별도로 더 추가해야 하는 코드는 없습니다.

Prisma에서 테이블에서 하나의 데이터를 찾는 것은 `findFirst` 메소드를 이용할 수 있습니다. `findFirst` 메소드의 인자로는 where 절에 들어가는 조건문을 객체의 형태로 표현하게 됩니다.

아래 예시는 `id`가 `1`인 데이터 하나를 찾는 쿼리입니다. 데이터를 찾지 못하면 `null`이 반환됩니다.

```jsx
await prisma.user.findFirst({ where: { id: 1 } });
```

이메일 값으로 데이터 하나를 찾고 싶다면, 아래와 같이 할 수 있습니다.

```jsx
await prisma.user.findFirst({ where: { email: "test@emxaple.com" } });
```

데이터를 생성할 때에는 `create` 메소드를 이용할 수 있습니다. 인자로는 데이터를 객체의 형태로 넣어주면 됩니다.

```jsx
await prisma.user.create({
  data: {
	  name: "엘빈",
	  email: "test@example.com",
	  ...,
	}
});
```

이런 내용을 토대로 기존의 `addUser` 함수를 개선해보면, 아래와 같습니다.

```jsx
// User 데이터 삽입
export const addUser = async (data) => {
  const user = await prisma.user.findFirst({ where: { email: data.email } });
  if (user) {
    return null;
  }

  const created = await prisma.user.create({ data: data });
  return created.id;
};

```

아주 간단해졌죠? ORM을 사용하면 SQL 쿼리를 직접 입력하고 파싱할 필요 없이 간단하게 처리할 수 있게 됩니다.

여기까지 수정하신 후에 API가 잘 동작하는지 확인해보시기 바랍니다!

그리고 `user.repository.js` 의 상단에는 

```jsx
import { prisma } from "../db.config.js";
```

가 있어야 함도 다들 눈치채셨죠? 

### 👉 ORM 마저 적용하기

아직 `getUser`, `setPreference`, `getUserPreferencesByUserId` 3가지 함수들은 ORM을 적용하지 않은 상태입니다. 오늘 워크북에서는 이 함수들을 마저 함께 수정해보도록 하겠습니다.

우선 Model들을 추가해보겠습니다.

```jsx
model User {
  id            Int      @id @default(autoincrement())
  email         String   @unique(map: "email") @db.VarChar(255)
  name          String   @db.VarChar(100)
  gender        String   @db.VarChar(15)
  birth         DateTime @db.Date
  address       String   @db.VarChar(255)
  detailAddress String?  @map("detail_address") @db.VarChar(255)
  phoneNumber   String   @map("phone_number") @db.VarChar(15)

  userFavorCategories UserFavorCategory[]

  @@map("user")
}

model FoodCategory {
  id   Int    @id @default(autoincrement())
  name String @db.VarChar(100)

  userFavorCategories UserFavorCategory[]

  @@map("food_category")
}

model UserFavorCategory {
  id             Int          @id @default(autoincrement())
  user           User         @relation(fields: [userId], references: [id])
  userId         Int          @map("user_id")
  foodCategory   FoodCategory @relation(fields: [foodCategoryId], references: [id])
  foodCategoryId Int          @map("food_category_id")

  @@index([foodCategoryId], map: "f_category_id")
  @@index([userId], map: "user_id")
  @@map("user_favor_category")
}
```

Prisma의 Schema 파일에서 테이블 간 Relation을 맺기 위해서 위와 같이 표현해준 것을 볼 수 있습니다. 다소 번거롭지만, 한 번 설정해두면 이후 ORM으로 더욱 편리하게 사용할 수 있습니다! (`1:m`과 `m:1`이 어떻게 설정되는지 잘 살펴보고 이해하고 넘어가시면 좋을 것 같습니다.)

이제 `src/repositories/user.repository.js` 파일을 한 번에 수정해보겠습니다.

```jsx
import { prisma } from "../db.config.js";

// User 데이터 삽입
export const addUser = async (data) => {
  const user = await prisma.user.findFirst({ where: { email: data.email } });
  if (user) {
    return null;
  }

  const created= await prisma.user.create({ data: data});
  return created.id;
};

// 사용자 정보 얻기
export const getUser = async (userId) => {
  const user = await prisma.user.findFirstOrThrow({ where: { id: userId } });
  return user;
};

// 음식 선호 카테고리 매핑
export const setPreference = async (userId, foodCategoryId) => {
  await prisma.userFavorCategory.create({
    data: {
      userId: userId,
      foodCategoryId: foodCategoryId,
    },
  });
};

// 사용자 선호 카테고리 반환
export const getUserPreferencesByUserId = async (userId) => {
  const preferences = await prisma.userFavorCategory.findMany({
    select: {
      id: true,
      userId: true,
      foodCategoryId: true,
      foodCategory: true,
    },
    where: { userId: userId },
    orderBy: { foodCategoryId: "asc" },
  });

  return preferences;
};
```

`getUser`

- 특정 사용자의 정보를 조회하는 함수입니다.
- `findFirstOrThrow` 메소드는 조건에 맞는 유저가 없을 경우 자동으로 에러를 발생시킵니다.
    
    → 별도로 `if (user)!` 체크를 하지 않아도 됩니다.
    
- `{ where: { id: userId } }` 로 단일 조회를 수행합니다.

`setPreference` 함수는 사용자와 음식 카테고리 간의 선호 관계를 매핑하는 함수입니다.

`create` 메소드 호출 시에 `foodCategoryId` 인자와 `userId` 인자에 각각 `id` 값을 전달하고 있습니다.

`getUserPreferencesByUserId` 함수는 JOIN으로 인해 다소 읽기 어려운데요, 천천히 살펴보겠습니다.

- `{ where: { userId: userId } }` → `userId` 값을 이용해 WHERE 절을 채워주었습니다. 특정 유저의 선호 데이터만 조회한다는 뜻입니다.
    - `{ select: { foodCategory: true } }` →`userFavorCategory` 테이블이 `foodCategory` 모델과 관계를 맺고 있기 때문에, JOIN을 통해 카테고리 상세 정보를 함께 조회하도록 했습니다.
    - `select` 값을 정의하지 않으면, 이후에 데이터를 조회했을 때 `foodCategory` 필드 대신 `foodCategoryId` 필드만 남아있는 것을 보게 됩니다.
        
        ```jsx
        [ { id: 24, userId: 28, foodCategoryId: 1 } ]
        ```
        
- `{ orderBy: { foodCategoryId: "asc" } }` → `foodCategoryId` 컬럼 값을 이용해 오름차순으로 정렬되도록 정의했습니다.

DTO는 아래와 같이 수정해주세요.

```jsx
...

export const responseFromUser = ({ user, preferences }) => {
  const preferFoods = preferences.map(
    (preference) => preference.foodCategory.name
  );

  return {
    email: user.email,
    name: user.name,
    preferCategory: preferFoods,
  };
};
```

기존에 `preference.name` 으로 조회하던 것을 이제 JOIN된 Entity를 거쳐 조회하도록 `preference.foodCategory.name` 로 변경되었습니다.

### 👉 마무리

최근 트렌드는 DB는 ORM을 이용해 가볍게 조회 및 사용하고, JavaScript 코드를 이용해서 데이터를 가공, 변형하여 사용하는 편입니다. DB에서는 최소한의 JOIN, 정렬, 집계 등만 수행한 후 코드 레벨에서 필드 이름의 변경, 데이터 조합, 재가공 등을 진행하는 것으로 이해하시면 됩니다.

그럼에도 ORM이 전송하는 SQL 쿼리가 어떤 형태인지 확인할 필요는 있는데요, 아래와 같이 옵션을 지정하여 실제로 DB에 전송되는 SQL 쿼리를 확인할 수 있습니다.

```jsx
export const prisma = new PrismaClient({ log: ["query"] });
```

![이렇게 파라미터들은 ?로 치환된 쿼리들이 보입니다!](Chapter%206%20ORM%20%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EA%B8%B0%20-%20ORM%20%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EA%B8%B0/CleanShot_2024-09-15_at_15.28.312x.png)

이렇게 파라미터들은 ?로 치환된 쿼리들이 보입니다!

TypeScript를 사용하면 ORM을 더욱 편하고 안전하게 사용할 수 있는데요, 이는 추후 워크북에서 함께 조금 더 살펴보도록 하겠습니다.