# Chapter 3. API 명세서의 작성

## 🤔 API 명세서의 필요성

백엔드 개발자가 API를 만들고, 프론트엔드 개발자가 그 API를 사용한다고 가정해 봅시다.

만약 “이 API는 어떤 요청을 받아서 어떤 응답을 주는지”에 대한 문서가 없다면 어떻게 될까요?

프론트엔드는 매번 백엔드에게 직접 물어봐야 할 것이고,

서로 같은 기능을 다르게 이해해서 개발이 꼬일 수도 있습니다.

이런 문제를 막기 위해 **API 명세서(API Specification)**가 필요합니다.

API 명세서는 “API를 어떻게 사용해야 하는지”를 약속한 설명서 역할을 하며, 팀원 간 원활한 협업을 가능하게 해줍니다. 

보통은 ERD를 먼저 설계하고 그 ERD를 기반으로 API 명세서를 작성합니다. 

실제 프론트엔드와 어떻게 데이터를 주고받을지 정리하는 거죠.

저희가 예시로 볼 ERD는 1주차의 ERD입니다!

![1주차 ERD](Chapter%203%20API%20%EB%AA%85%EC%84%B8%EC%84%9C%EC%9D%98%20%EC%9E%91%EC%84%B1%20278b57f4596b8126992ac449d0030b5d/image.png)

1주차 ERD

그러면 이제 API 명세서를 작성할 때 포함해야 할 주요 요소들을 한번 살펴보겠습니다. 

## 😋 API 명세서의 주요 요소

### 1. Endpoint (엔드포인트)

ex./api/v1/users/signup 

### 2. Method (메소드)

ex. **GET**, **POST,** **PUT**, **PATCH**, **DELETE** 

### 3. Request / Response (요청/응답)

### 4.Status Code (상태 코드)

ex. 200 OK, 400 Bad Request, 401 Unauthorized 등 요청 처리 결과를 나타내는 숫자 코드입니다. 

### 5. Error Case (에러 상황)

실패했을 때 반환되는 응답

API 명세서를 본격적으로 작성하기 전 마지막으로 한번 정리하자면, 

Endpoint와 Method는 API가 어떤 기능을 하는지 가장 먼저 알 수 있는 부분이고,

Request+Response는 프론트와 백엔드가 맞춰야 하는 핵심이라고 볼 수 있습니다.

그리고 Status Code는 성공과 실패 여부를 빠르게 알 수 있는 수단입니다. 

그렇지만 성공과 실패만 표시하면 프론트엔드가 작업을 할 때 쉽지 않겠죠?

그래서 Error Case(에러 상황)을 꼭 제대로 문서화 해주어야 합니다.

여기에 예시도 넣어주면 더 좋구요. 

그럼 이제 실제로 API 명세서를 작성해 볼까요?

## 😎 API 명세서 작성하기

제가 제시해 드린 건 예시일 뿐이며, 꼭 이렇게 지킬 필요가 없습니다.

작성 방식은 본인이 가장 편하고 이해하기 쉬운 형태로 자유롭게 구성하셔도 됩니다. 

[API 명세서 예시 ](Chapter%203%20API%20%EB%AA%85%EC%84%B8%EC%84%9C%EC%9D%98%20%EC%9E%91%EC%84%B1%20278b57f4596b8126992ac449d0030b5d/API%20%EB%AA%85%EC%84%B8%EC%84%9C%20%EC%98%88%EC%8B%9C%20278b57f4596b81389cf4e2247b6d62f7.csv)

일단 회원가입은 모든 서비스의 기본이겠죠?

회원가입부터 한번 만들어 볼게요.

### Endpoint, Method

일단 Endpoint는 /api/v1/users/signup으로 정했습니다.

앞의 v1은 버전이에요. 

서비스가 커지면 API 구조가 바뀌거나 응답 형식이 달라질 수 있거든요.

그때 새로운 기능을 v2에서 제공하면 됩니다. 

그리고 프론트엔드, 모바일 앱 등 여러 클라이언트가 API를 쓰고 있을 때 한 번에 모든 코드를 바꾸기는 쉽지 않습니다. 

버전을 표시해 두면 기존 앱이 깨지지 않고 계속 동작할 수가 있어요.

Method는 POST겠죠? 이 부분은 따로 설명하지 않겠습니다!

### Request Header

Request Header는 클라이언트가 서버에 요청을 보낼 때 **추가적인 정보(Meta data)**를 담아 보내는 영역입니다. 

Header는 보통 본문(Request Body)과는 별개로 “이 요청이 어떤 성격인지”, “어떤 인증 정보를 가지고 있는지” 등을 알려줘요.

자주 쓰이는 Request Header로는 Content-Type과 Authorization이 있어요.

사실 둘 다 많이 쓰이지만, Authorization은 정말 중요합니다.

API를 개발할 땐 꼭 Authorization 과정을 거치게 해야만 해요.

(회원가입 API에서는 당연히 필요하지 않습니다!) 

여기서 말하는 API는 로그인 이후의 API입니다. 

일단 이번주에는 이정도만 알고, 나중에 API를 구현할 때 다시 한번 보도록 할게요.

### Request, Response

이제 Request, Response를 한번 설계해 볼게요. 

이것도 보통 이런 식으로 작성한다는것을 제시해드리는 것 뿐 팀 상황에 따라 자유롭게 응용하시면 됩니다. 

**Request (회원가입 요청)**

API에서 주고받는 데이터 형식은 보통 JSON을 사용합니다. 

읽기 쉽고, 다루기도 쉬워요.

모바일 앱에서도 동일하게 사용할 수 있고, XML과 같은 다른 포맷보다 문법도 간단하고 데이터 크기도 작다는 이점이 있어서 정말 많이 쓰입니다. 

```json
{
	"email": "test@example.com",
	"password": "hk1234",
	"name": "전하경",
	"phoneNum": "010-0000-0000",
	"nickName": "재서",
	"gender": "F" 
}
```

여기서도 고려해야 될 점이 조금 있는데요.

전화번호 형식 같은 게 **010-0000-0000**처럼 -를 넣을 수도 있고**, 01000000000**처럼 숫자만 보낼 수도 있잖아요? 

이런 건 API 명세서에 어떤 형식을 쓸지 미리 규정해 줘야 나중에 귀찮은 일을 조금이나마 줄일 수 있습니다.

**Response(회원가입 성공 응답)** 

```json
{
  "success": true,
  "code": "S200",
  "message": "회원가입이 완료되었습니다.",
  "data": {
    "id": 1,
    "name": "전하경"
  }
}
```

code는 S200도 괜찮고 SUCCESS200도 좋습니다.

다른 방법도 프런트엔드와 협의가 되었고 알아들을 수 있는 명세라면 얼마든지 좋아요!

### 에러 처리

사실, 성공 응답을 구성하는 것보다 더 중요한 것은 에러 처리입니다.

에러 처리를 어떻게 할 지 미리 정의하는 것이 훨씬 중요합니다.

회원가입에 대한 에러 처리도 정말 여러 가지가 있겠죠?

이메일 중복, 비밀번호 형식 틀림, 필드 누락, 서버 내부 오류 등등..

회원가입 한 기능에도 다양한 에러가 발생할 수 있습니다.

처음 개발 할 때부터 모든 에러를 잡기는 쉽진 않겠지만, 

일단 최대한 일어날 수 있는 상황을 생각하고 가정하다 보면 시간을 의미있게 아낄 수 있을 거라 생각합니다.

이메일 중복

```json
{
	"success": false,
	"code": "E4001",
	"message":"이미 존재하는 이메일입니다.",
	"data":null
}
```

비밀번호 형식 틀림

비밀번호  규칙 어김 (8자 이상이라던가.. 특수문자를 포함한다던가..)

```json
{
	"success": false,
	"code": "E4002",
	"message":"비밀번호 형식이 올바르지 않습니다.",
	"data":null
}
```

서버 내부 오류

```json
{
	"success": false,
	"code": "E5000",
	"message":"서버 내부 오류가 발생했습니다.",
	"data":null
}
```

이제 마지막으로 책에 좋아요 누르는 API 하나만 보고 이제 정말 실제로 API 명세서를 작성해보는 시간을 가져봅시다!

## 📙 책에 좋아요 누르는 API

### Endpoint ,Method

**POST** /api/v1/books/{id}/likes

### Request Header

```json
Authorization: Bearer {accessToken}
Content-Type: application/json
```

좋아요 기능은 로그인한 사용자만 할 수 있으므로 **Authorization**이 필요합니다. 

중요한 포인트!

여기서 Authorization 과정을 거친다는 것은 누가 좋아요를 누르는지 식별이 가능하다는 이야기겠죠?

그러면 Body로 어떤 유저가 좋아요를 눌렀는지 memberId를 보내줄 필요가 없어요.

그래서 Request Body는 없고 Response만 보내주면 됩니다.

```json
{
  "success": true,
  "code": "S200",
  "message": "좋아요가 등록되었습니다.",
  "data": {
    "likeId": 15,
    "bookId": 7,
    "memberId": 2,
    "created_at": "2025-09-16T12:00:00"
  }
}
```

---

Copyright © 2025 전하경(재서) All rights reserved.